// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leaderboard.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const getCompetitionLeaderboard = `-- name: GetCompetitionLeaderboard :many
SELECT
    cm.trading_account_login::BIGINT as trading_account_login,
    
    ROW_NUMBER() OVER (
    ORDER BY
      COALESCE(
        (COALESCE(SUM(t.profit + t.commission + t.swap), 0) / NULLIF(cm.account_size, 0)) * 100,
        0
      ) DESC
  )::INT AS rank,

    u.username,
    cm.account_size::FLOAT8 AS account_size,

    COALESCE(SUM(t.profit + t.commission + t.swap), 0)::FLOAT8 AS profit,

    (cm.account_size + COALESCE(SUM(t.profit + t.commission + t.swap), 0))::FLOAT8 AS equity,

    COALESCE(
            (COALESCE(SUM(t.profit + t.commission + t.swap), 0) / NULLIF(cm.account_size, 0)) * 100,
            0
    )::FLOAT8 AS gain_percent

FROM competition_members cm
JOIN trading_accounts ta ON ta.login = cm.trading_account_login
JOIN users u ON u.id = ta.user_id
LEFT JOIN trades t ON t.trading_account_login = cm.trading_account_login
AND t.competition_id = cm.competition_id

WHERE cm.competition_id = $1

GROUP BY
    cm.trading_account_login,
    cm.account_size,
    u.username

ORDER BY gain_percent DESC
LIMIT $2 OFFSET $3
`

type GetCompetitionLeaderboardParams struct {
	CompetitionID uuid.UUID `db:"competition_id" json:"competition_id"`
	Limit         int32     `db:"limit" json:"limit"`
	Offset        int32     `db:"offset" json:"offset"`
}

type GetCompetitionLeaderboardRow struct {
	TradingAccountLogin int64   `db:"trading_account_login" json:"trading_account_login"`
	Rank                int32   `db:"rank" json:"rank"`
	Username            string  `db:"username" json:"username"`
	AccountSize         float64 `db:"account_size" json:"account_size"`
	Profit              float64 `db:"profit" json:"profit"`
	Equity              float64 `db:"equity" json:"equity"`
	GainPercent         float64 `db:"gain_percent" json:"gain_percent"`
}

func (q *Queries) GetCompetitionLeaderboard(ctx context.Context, arg GetCompetitionLeaderboardParams) ([]GetCompetitionLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getCompetitionLeaderboard, arg.CompetitionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompetitionLeaderboardRow
	for rows.Next() {
		var i GetCompetitionLeaderboardRow
		if err := rows.Scan(
			&i.TradingAccountLogin,
			&i.Rank,
			&i.Username,
			&i.AccountSize,
			&i.Profit,
			&i.Equity,
			&i.GainPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
